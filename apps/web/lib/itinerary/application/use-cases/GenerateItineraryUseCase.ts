/**
 * Application Use Case: GenerateplanUseCase
 * Orchestrates the plan generation process
 * Follows Clean Architecture principles
 *
 * Features intelligent database-backed caching to reduce Groq API calls
 */

import { plan as Plan } from '../../domain/entities/Itinerary'
import { LocationRepository } from '../../infrastructure/repositories/LocationRepository'
import { RouteCalculatorService } from '../services/RouteCalculatorService'
import { GroqAIService } from '../services/GroqAIService'
import { EnhancedGroqAIService } from '../services/EnhancedGroqAIService'
import { getCachedItineraryRepository, CacheKey } from '../../infrastructure/repositories/CachedItineraryRepository'

import { createGroqClient } from '@/lib/groq'

export interface GenerateplanCommand {
  from: string // location slug or name
  to: string // location slug or name
  stops?: string[] // optional middle stops (slugs or names)
  startDate: string // ISO date
  endDate: string // ISO date
  interests?: string[]
  budget?: 'budget' | 'moderate' | 'luxury'
  maxTravelHoursPerDay?: number // Optional: max travel hours per day (e.g., 4)
  transportMode?: 'car' | 'train' | 'bike' | 'flight' | 'bus' | 'mixed' // Transport mode
  proMode?: boolean // Enable Pro mode with reasoning AI
  forceRefresh?: boolean // Force regeneration, bypass cache
  tripType?: 'road-trip' | 'bike' | 'family' | 'adventure' | 'luxury' | 'city' | 'solo' | 'wellness' | 'specific' | 'journey' | 'multi-destination' // Trip style
  tripVision?: string // Free-text user preferences to steer planning

}

export interface ResolvedLocation {
  userInput: string
  resolvedName: string
  country?: string
  region?: string
}

export interface GenerateplanResult {
  success: boolean
  plan?: Plan
  error?: string
  resolvedLocations?: ResolvedLocation[]
  locationImages?: Record<string, { featured: string; gallery: string[] }> // Map of location name to image data with gallery
  // NEW: structured context (routing, POIs, etc.) surfaced to API
  structuredContext?: any
  // NEW: optional headline/subtitle generated by GROQ
  groqHeadline?: string
  groqSubtitle?: string
  // NEW: generation mode metadata for UI/analytics
  generationMode?: 'standard' | 'pro' | 'two-stage'
}

export class GenerateplanUseCase {
  private locationRepo: LocationRepository
  private routeCalculator: RouteCalculatorService
  private aiService: GroqAIService

  constructor() {
    this.locationRepo = new LocationRepository()
    this.routeCalculator = new RouteCalculatorService(this.locationRepo)
    this.aiService = new GroqAIService()
  }

  /**
   * Execute the use case
   */
  async execute(command: GenerateplanCommand): Promise<GenerateplanResult> {
    try {
      console.log('üöÄ Starting plan generation:', command)

      // 1. Validate command
      this.validateCommand(command)

      // 2. Calculate route with user-specified stops
      console.log('üõ£Ô∏è Calculating route...')
      const routeInfo = await this.routeCalculator.calculateRouteWithStops(
        command.from,
        command.to,
        command.stops || []
      )

      // 3. Calculate total days
      const totalDays = this.routeCalculator.calculateTotalDays(
        command.startDate,
        command.endDate
      )
      console.log(`üìÖ Total days: ${totalDays}`)

      // 4. Validate days vs route
      if (totalDays < 2) {
        return {
          success: false,
          error: 'Trip must be at least 2 days long'
        }
      }

      // Calculate minimum days: 1 day per location + travel days
      // More lenient: allow short trips if distance is small
      const travelDays = routeInfo.calculateTravelDays()
      const numLocations = 2 + routeInfo.stops.length // from + to + stops
      // Removed restrictive validation - users should be free to plan trips of any duration
      // The AI will adapt the itinerary to fit the available time

      // 5. Check cache (unless force refresh requested)
      if (!command.forceRefresh) {
        const cacheParams: CacheKey = {
          fromLocation: routeInfo.fromLocation,
          toLocation: routeInfo.toLocation,
          stops: routeInfo.stops.map(s => s.name),
          totalDays,
          interests: command.interests || [],
          budget: command.budget || 'moderate'
        }

        // Try exact match first
        console.log('üîç Checking cache for exact match...')
        const cacheRepo = getCachedItineraryRepository()
        let cachedPlan = await cacheRepo.findByExactMatch(cacheParams)

        // If no exact match, try similar plans
        if (!cachedPlan) {
          console.log('üîç Checking cache for similar plans...')
          cachedPlan = await cacheRepo.findSimilar(cacheParams)
        }

        // If cache hit, return cached plan
        if (cachedPlan) {
          console.log(`‚ö° Cache hit! Returning cached plan (used ${cachedPlan.usageCount} times)`)

          // Create Plan entity from cached data
          const plan = Plan.create({
            title: cachedPlan.planData.title,
            summary: cachedPlan.planData.summary,
            days: cachedPlan.planData.days,
            totalCostEstimate: cachedPlan.planData.totalCostEstimate,
            tips: cachedPlan.planData.tips
          })

          // Fetch location images even for cached plans WITH GALLERY SUPPORT
          console.log('üñºÔ∏è Fetching location images with galleries for cached plan...')
          const locationImages = await this.locationRepo.getLocationImagesWithGallery([
            routeInfo.fromLocation,
            ...routeInfo.stops.map(s => s.name),
            routeInfo.toLocation
          ])

          // Build resolved locations
          const resolvedLocations: ResolvedLocation[] = [
            {
              userInput: command.from,
              resolvedName: routeInfo.fromLocation
            },
            ...routeInfo.stops.map((stop, index) => ({
              userInput: command.stops?.[index] || stop.name,
              resolvedName: stop.name
            })),
            {
              userInput: command.to,
              resolvedName: routeInfo.toLocation
            }
          ]

          return {
            success: true,
            plan,
            resolvedLocations,
            locationImages
          }
        }

        console.log('‚ùå Cache miss - generating new plan with AI')
      } else {
        console.log('üîÑ Force refresh requested - bypassing cache')
      }

      // 6. Fetch location data (activities & restaurants) from DATABASE
      console.log('üìä Fetching location data from database...')
      const locationSlugs = [
        routeInfo.fromSlug || command.from, // Use slug from routeInfo if available
        ...routeInfo.stops.map(s => s.slug),
        routeInfo.toSlug || command.to      // Use slug from routeInfo if available
      ]

      console.log('üîç Fetching data for slugs:', locationSlugs)
      const locationsData = await this.fetchLocationsData(locationSlugs)

      if (locationsData.length === 0) {
        console.error('‚ùå No location data found for slugs:', locationSlugs)
        return {
          success: false,
          error: 'Could not fetch location data'
        }
      }

      // 6.2. Pre-compute structured context (routing + POIs) to maximize realism and enable DB reuse
      let structuredContext: any = {}
      try {
        const fromSlug = routeInfo.fromSlug || command.from
        const toSlug = routeInfo.toSlug || command.to

        // Build quick lookup
        const bySlug = new Map(locationsData.map(ld => [ld.slug, ld]))

        // Coordinates list in travel order
        const coords: Array<{ longitude: number; latitude: number }> = []
        const fromLoc = bySlug.get(fromSlug)
        if (fromLoc?.longitude && fromLoc?.latitude) {
          coords.push({ longitude: fromLoc.longitude, latitude: fromLoc.latitude })
        }
        for (const s of routeInfo.stops) {
          const stop = bySlug.get(s.slug)
          if (stop?.longitude && stop?.latitude) {
            coords.push({ longitude: stop.longitude, latitude: stop.latitude })
          } else if (s.coordinates) {
            coords.push({ longitude: s.coordinates.longitude, latitude: s.coordinates.latitude })
          }
        }
        const toLoc = bySlug.get(toSlug)
        if (toLoc?.longitude && toLoc?.latitude) {
          coords.push({ longitude: toLoc.longitude, latitude: toLoc.latitude })
        }

        // Compute routing (cached via DB providers)
        if (coords.length >= 2) {
          const { getRoute } = await import('../../../services/routingService')
          const profile = ((): 'driving-car' | 'cycling-regular' | 'foot-walking' | 'wheelchair' => {
            switch (command.transportMode) {
              case 'bike':
                return 'cycling-regular'
              case 'train':
              case 'bus':
              case 'car':
              case 'mixed':
              default:
                return 'driving-car'
            }
          })()
          const route = await getRoute(coords as any, profile)

          // Extract geometry coordinates (handle both GeoJSON and plain array)
          const routeGeometry = Array.isArray(route.geometry)
            ? route.geometry
            : route.geometry.coordinates

          structuredContext.routing = {
            distanceKm: route.distance / 1000,
            durationHours: route.duration / 3600,
            provider: route.provider,
            geometry: route.geometry // GeoJSON LineString [lng, lat] pairs
          }

          // NEW: Route Segmentation (if maxTravelHoursPerDay specified)
          if (command.maxTravelHoursPerDay && command.maxTravelHoursPerDay > 0) {
            console.log(`üó∫Ô∏è Segmenting route by ${command.maxTravelHoursPerDay}h/day...`)
            const { segmentRouteByDrivingTime, calculateOvernightStops } = await import('../../../services/routeSegmentationService')

            try {
              const segments = segmentRouteByDrivingTime({
                routeGeometry: routeGeometry,
                totalDistanceKm: route.distance / 1000,
                totalDurationHours: route.duration / 3600,
                maxDrivingHoursPerDay: command.maxTravelHoursPerDay,
                startDate: command.startDate,
                startTime: '09:00', // Default departure time
                locations: locationsData.map(loc => ({
                  name: loc.name,
                  coordinates: [loc.longitude, loc.latitude] as [number, number]
                }))
              })

              const overnightStops = calculateOvernightStops(segments)

              structuredContext.routeSegments = segments
              structuredContext.overnightStops = overnightStops

              console.log(`‚úÖ Created ${segments.length} route segments with ${overnightStops.length} overnight stops`)
            } catch (error) {
              console.error('‚ö†Ô∏è Failed to segment route:', error)
              structuredContext.routeSegments = []
              structuredContext.overnightStops = []
            }
          }

          // OPTIMIZATION: Skip comprehensive data gathering for short trips (< 3 days)
          // This saves 2-3 API calls for quick getaways
          let aiFormattedData = null

          if (totalDays >= 3) {
            console.log('üîç Gathering comprehensive trip data from ALL sources...')
            const { isFeatureEnabled } = await import('../../../featureFlags')
            const { gatherComprehensiveTripData } = await import('../../../services/comprehensiveTripDataService')
            const {
              compressTripDataForAI,
              formatCompressedDataForAI,
              fitsWithinTokenLimit,
              compressTripDataForStorage
            } = await import('../../../services/tripDataCompressor')

            let comprehensiveData
            let compressedData

            try {
              // 1. Gather comprehensive data (with smart caching if enabled)
              if (isFeatureEnabled('SMART_POI_SYSTEM')) {
                const { smartFetch } = await import('../../../services/smartDataHandler')

                comprehensiveData = await smartFetch(
                  `trip_data_${routeInfo.fromLocation}_${routeInfo.toLocation}`,
                  'pois',
                  async () => {
                    return await gatherComprehensiveTripData(
                      routeInfo.fromLocation,
                      routeInfo.toLocation,
                      routeGeometry,
                      route.distance / 1000,
                      route.duration / 3600
                    )
                  },
                  { useServerClient: true }
                )
              } else {
                // Fallback: Direct fetch without caching
                comprehensiveData = await gatherComprehensiveTripData(
                  routeInfo.fromLocation,
                  routeInfo.toLocation,
                  routeGeometry,
                  route.distance / 1000,
                  route.duration / 3600
                )
              }

              console.log('‚úÖ Comprehensive data gathered:')
              console.log(`   Total POIs: ${comprehensiveData.pois.total}`)
              console.log(`   Activities: ${comprehensiveData.activities.length}`)
              console.log(`   Restaurants: ${comprehensiveData.restaurants.length}`)
              console.log(`   Facts: ${comprehensiveData.facts.length}`)

              // 2. Compress data for AI processing
              compressedData = compressTripDataForAI(comprehensiveData)

              // 3. Format for AI prompt (OPTIMIZATION: only top POIs)
              aiFormattedData = formatCompressedDataForAI(
                compressedData,
                command.transportMode || 'car',
                totalDays,
                command.interests || []
              )

              // 4. Check token limit
              if (!fitsWithinTokenLimit(aiFormattedData, 5000)) {
                console.warn('‚ö†Ô∏è Compressed data still too large, using fallback')
                aiFormattedData = null
              }

              // 5. Store compressed version in context (for database)
              structuredContext.comprehensiveData = compressTripDataForStorage(comprehensiveData)
              structuredContext.compressedData = compressedData
              structuredContext.aiFormattedData = aiFormattedData

            } catch (error) {
              console.error('‚ö†Ô∏è Failed to gather comprehensive data:', error)
            }
          } else {
            console.log('‚è≠Ô∏è Skipping comprehensive data gathering for short trip (< 3 days)')
          }

          // OPTIMIZATION: Skip redundant POI fetching
          // Comprehensive data gathering above is sufficient for most trips
          console.log('‚úÖ Using comprehensive data for route planning (POI fetching optimized away)')
        }

        // Fetch POIs with hours cheaply per location (OpenTripMap/WikiVoyage-backed)
        const { fetchCompleteLocationData } = await import('../../../services/locationDataService')
        const poisByLocation: Record<string, Array<{ name: string; category?: string; latitude?: number; longitude?: number }>> = {}
        for (const loc of locationsData) {
          if (typeof loc.latitude === 'number' && typeof loc.longitude === 'number') {
            const data = await fetchCompleteLocationData(loc.name, loc.latitude, loc.longitude)
            const top = (data.attractions || []).slice(0, 12).map((a: any) => ({
              name: a.name || a.title || 'POI',
              category: (a.kinds || a.category || '').split(',')[0] || undefined,
              latitude: a.latitude,
              longitude: a.longitude
            }))
            poisByLocation[loc.name] = top
          }
        }
        structuredContext.poisByLocation = poisByLocation
      } catch (err) {
        console.warn('‚ö†Ô∏è Structured context pre-compute failed (non-fatal):', err)
      }

      // 6.5. Separate locations: COMPLETE (use DB) vs INCOMPLETE (need AI enrichment)
      const completeLocations = locationsData.filter(loc => loc.hasCompleteData)
      const incompleteLocations = locationsData.filter(loc => !loc.hasCompleteData)

      console.log('\n' + '‚ïê'.repeat(80))
      console.log('üìä DATABASE OPTIMIZATION REPORT')
      console.log('‚ïê'.repeat(80))
      console.log(`‚úÖ ${completeLocations.length}/${locationsData.length} locations have COMPLETE data in database`)
      console.log(`   ‚Üí Will use existing activities, restaurants, images, coordinates`)
      console.log(`   ‚Üí NO external API calls needed for these locations`)
      console.log(`‚ö†Ô∏è  ${incompleteLocations.length}/${locationsData.length} locations have LIMITED data`)
      console.log(`   ‚Üí Will use available data + AI for enrichment`)

      if (completeLocations.length > 0) {
        console.log('\nüì¶ COMPLETE LOCATIONS (using database):')
        completeLocations.forEach(l => {
          console.log(`   ‚Ä¢ ${l.name}: ${l.activities.length} activities, ${l.restaurants.length} restaurants, ${l.featuredImage ? 'image ‚úì' : 'no image'}`)
        })
      }

      if (incompleteLocations.length > 0) {
        console.log('\nüîß LIMITED LOCATIONS (need enrichment):')
        incompleteLocations.forEach(l => {
          console.log(`   ‚Ä¢ ${l.name}: ${l.activities.length} activities, ${l.restaurants.length} restaurants`)
        })
      }

      const estimatedApiSavings = completeLocations.length * 3 // 3 API calls per location (activities, restaurants, images)
      console.log(`\nüí∞ ESTIMATED API SAVINGS: ${estimatedApiSavings} external API calls avoided`)
      console.log('‚ïê'.repeat(80) + '\n')

      // 7. Generate plan using AI (Direct structured output from reasoning model)
      console.log(`ü§ñ Generating plan with AI (Direct Structured)...`)

      let aiResult: any
      let generationMode: 'standard' | 'pro' | 'two-stage' = 'standard'

      // Use direct structured output from reasoning model
      generationMode = 'two-stage' // Keep name for backward compatibility
      aiResult = await this.generateWithDirectStructuredOutput(
        {
          fromLocation: routeInfo.fromLocation,
          toLocation: routeInfo.toLocation,
          totalDays,
          routeDistance: routeInfo.distanceKm,
          routeDuration: routeInfo.estimatedDurationHours,
          stops: routeInfo.stops.map(s => s.name),
          interests: command.interests || [],
          budget: command.budget || 'moderate',
          maxTravelHoursPerDay: command.maxTravelHoursPerDay,
          transportMode: command.transportMode,
          tripType: command.tripType,
          tripVision: command.tripVision,
          locationsData,
          structuredContext
        },
        command.startDate
      )

      if (command.proMode) {
        // Use enhanced AI service with reasoning model
        generationMode = 'pro'
        const enhancedAI = new EnhancedGroqAIService()
        aiResult = await enhancedAI.generateWithProMode(
          {
            fromLocation: routeInfo.fromLocation,
            toLocation: routeInfo.toLocation,
            totalDays,
            routeDistance: routeInfo.distanceKm,
            routeDuration: routeInfo.estimatedDurationHours,
            stops: routeInfo.stops.map(s => s.name),
            interests: command.interests || [],
            budget: command.budget || 'moderate',
            maxTravelHoursPerDay: command.maxTravelHoursPerDay,
            transportMode: command.transportMode,
            tripType: command.tripType,
            tripVision: command.tripVision,
            locationsData,
            structuredContext
          },
          command.startDate
        )
      } else {
        // Use standard AI service
        generationMode = 'standard'
        aiResult = await this.aiService.generateplan(
          {
            fromLocation: routeInfo.fromLocation,
            toLocation: routeInfo.toLocation,
            totalDays,
            routeDistance: routeInfo.distanceKm,
            routeDuration: routeInfo.estimatedDurationHours,
            stops: routeInfo.stops.map(s => s.name),
            interests: command.interests || [],
            budget: command.budget || 'moderate',
            maxTravelHoursPerDay: command.maxTravelHoursPerDay,
            transportMode: command.transportMode,
            tripType: command.tripType,
            tripVision: command.tripVision,
            locationsData,
            structuredContext
          },
          command.startDate
        )
      }

      // 8. PROFESSIONAL INTEGRATION: Enrich locations with AI metadata
      console.log('üåç Enriching locations with AI metadata...')
      await this.enrichLocationsWithAIMetadata(aiResult.days)

      // 8.5. AUTO-GENERATE GROQ HEADLINE (NEW!)
      console.log('‚ú® Auto-generating GROQ headline...')
      let groqHeadline = aiResult.title // Fallback to AI title
      let groqSubtitle = aiResult.summary // Fallback to AI summary

      try {
        const destinations = [
          routeInfo.fromLocation,
          ...routeInfo.stops.map(s => s.name),
          routeInfo.toLocation
        ]

        const headlineResponse = await fetch(`${process.env.NEXT_PUBLIC_SITE_URL || 'http://localhost:3000'}/api/groq/generate-headline`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            destinations,
            duration: totalDays,
            tripType: command.interests?.[0] || 'Adventure'
          })
        })

        if (headlineResponse.ok) {
          const { headline, subtitle } = await headlineResponse.json()
          groqHeadline = headline
          groqSubtitle = subtitle
          console.log(`‚úÖ GROQ headline generated: "${headline}"`)
        } else {
          console.warn('‚ö†Ô∏è GROQ headline generation failed, using AI title')
        }
      } catch (error) {
        console.error('‚ùå Error generating GROQ headline:', error)
        console.log('‚ö†Ô∏è Using AI title as fallback')
      }

      // 9. Validate AI days and fallback if needed to avoid repeated same-day/location
      let finalDays = aiResult.days
      try {
        const expected = totalDays
        const daysLen = Array.isArray(aiResult.days) ? aiResult.days.length : 0
        const uniqueLocations = new Set((aiResult.days || []).map((d: any) => d.location)).size
        const hasTravel = (aiResult.days || []).some((d: any) => d.type === 'travel')
        const routeIsLong = (routeInfo.distanceKm || 0) > 200

        const needsFallback = !daysLen || daysLen < Math.max(2, Math.floor(expected * 0.6)) || (routeIsLong && uniqueLocations <= 1)

        if (needsFallback) {
          console.warn('‚ö†Ô∏è AI days look weak, generating route-based fallback days...',{ daysLen, expected, uniqueLocations, routeIsLong })
          const { segmentRouteByDrivingTime } = await import('../../../services/routeSegmentationService')

          const routingGeom: any = (structuredContext as any)?.routing?.geometry
          const routeGeometryArr: number[][] = Array.isArray(routingGeom) ? routingGeom : (routingGeom?.coordinates || [])

          const segments = segmentRouteByDrivingTime({
            routeGeometry: routeGeometryArr,
            totalDistanceKm: routeInfo.distanceKm,
            totalDurationHours: routeInfo.estimatedDurationHours,
            maxDrivingHoursPerDay: command.maxTravelHoursPerDay || 5,
            startDate: command.startDate,
            startTime: '09:00',
            locations: locationsData.map((loc: any) => ({ name: loc.name, coordinates: [loc.longitude, loc.latitude] as [number, number] }))
          })

          // Build simple day sequence: start stay (1d) -> for each segment: travel -> optional stay -> end stay (remaining)
          const addDays = (dateStr: string, n: number) => {
            const d = new Date(dateStr); d.setDate(d.getDate() + n); return d.toISOString().split('T')[0]
          }
          const startDate = command.startDate
          const result: any[] = []
          let dayNo = 1

          // Ensure at least a start stay day
          result.push({ day: dayNo++, date: addDays(startDate, 0), location: routeInfo.fromLocation, type: 'stay', items: [] })

          for (let i = 0; i < segments.length && dayNo <= expected; i++) {
            const seg = segments[i]
            // travel day
            if (dayNo <= expected) {
              result.push({
                day: dayNo++,
                date: addDays(startDate, dayNo - 2), // travel starts after day 1
                location: `${seg.startLocation.name} ‚Üí ${seg.endLocation.name}`,
                type: 'travel',
                items: [],
                travelInfo: { from: seg.startLocation.name, to: seg.endLocation.name, distance: seg.distanceKm, duration: seg.drivingTimeHours, mode: command.transportMode || 'car' }
              })
            }
            // quick stay at end of segment if days remain (1 day)
            if (i < segments.length - 1 && dayNo <= expected) {
              result.push({ day: dayNo++, date: addDays(startDate, dayNo - 1), location: seg.endLocation.name, type: 'stay', items: [] })
            }
          }
          // Fill remaining days at destination as stay
          while (dayNo <= expected) {
            result.push({ day: dayNo, date: addDays(startDate, dayNo - 1), location: routeInfo.toLocation, type: 'stay', items: [] })
            dayNo++
          }
          finalDays = result
        }
      } catch (e) {
        console.warn('‚ö†Ô∏è Fallback day generation failed, using AI days as-is', e)
      }

      const plan = Plan.create({
        title: aiResult.title,
        summary: aiResult.summary,
        days: finalDays,
        totalCostEstimate: aiResult.totalCostEstimate,
        tips: aiResult.tips,
        transportMode: command.transportMode // Include transport mode
      })

      // 10. Save to cache for future reuse WITH GROQ HEADLINE
      console.log('üíæ Saving plan to cache with GROQ headline...')
      const cacheParams: CacheKey = {
        fromLocation: routeInfo.fromLocation,
        toLocation: routeInfo.toLocation,
        stops: routeInfo.stops.map(s => s.name),
        totalDays,
        interests: command.interests || [],
        budget: command.budget || 'moderate'
      }

      const cacheRepo = getCachedItineraryRepository()
      await cacheRepo.save(cacheParams, {
        title: aiResult.title,
        summary: aiResult.summary,
        days: aiResult.days,
        totalCostEstimate: aiResult.totalCostEstimate,
        tips: aiResult.tips,
        __context: structuredContext, // Persist structured context inside plan_data for reuse
        __groqHeadline: groqHeadline, // Cache GROQ headline
        __groqSubtitle: groqSubtitle  // Cache GROQ subtitle
      }).catch(error => {
        // Don't fail the request if caching fails
        console.error('‚ö†Ô∏è Failed to cache plan:', error)
      })

      // 10. Fetch location images from database WITH GALLERY SUPPORT
      console.log('üñºÔ∏è Fetching location images with galleries...')
      const locationImages = await this.locationRepo.getLocationImagesWithGallery([
        routeInfo.fromLocation,
        ...routeInfo.stops.map(s => s.name),
        routeInfo.toLocation
      ])

      // 11. Build resolved locations list for transparency
      const resolvedLocations: ResolvedLocation[] = [
        {
          userInput: command.from,
          resolvedName: routeInfo.fromLocation
        },
        ...routeInfo.stops.map((stop, index) => ({
          userInput: command.stops?.[index] || stop.name,
          resolvedName: stop.name
        })),
        {
          userInput: command.to,
          resolvedName: routeInfo.toLocation
        }
      ]

      console.log('‚úÖ plan generated successfully!')
      console.log('üìç Resolved locations:', resolvedLocations)
      console.log(`üñºÔ∏è Fetched ${Object.keys(locationImages).length} location images`)
      console.log(`‚ú® GROQ headline: "${groqHeadline}"`)

      return {
        success: true,
        plan,
        resolvedLocations,
        locationImages,
        structuredContext,
        groqHeadline,  // Return GROQ headline
        groqSubtitle,  // Return GROQ subtitle
        generationMode // Expose generation mode for UI/analytics
      }

    } catch (error) {
      console.error('‚ùå Error generating plan:', error)
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred'
      }
    }
  }

  /**
   * OPTIMIZATION: Smart model selection based on trip complexity
   * Simple trips use fast, cheap model; complex trips use reasoning model
   *
   * Model costs (approximate):
   * - llama-3.3-70b-versatile: $0.07/1M tokens (baseline)
   * - openai/gpt-oss-20b: $0.10/1M tokens (50% cheaper than 120B)
   * - openai/gpt-oss-120b: $0.20/1M tokens (most expensive)
   */
  private selectOptimalModel(tripDays: number, routeKm: number): string {
    // Simple trips: use fast, cheap model (2-3x faster, 50% cheaper)
    if (tripDays <= 5 && routeKm <= 500) {
      return 'llama-3.3-70b-versatile'
    }

    // Complex trips: use GPT-OSS 20B (50% cheaper than 120B, tested & verified)
    // ‚úÖ Test Results (10-day Rio‚ÜíBuenos Aires):
    //    - Duration: 2.99s (faster than 120B's 4.2s)
    //    - Tokens: 2349 (vs 2688 with 2500 limit)
    //    - Cost: $0.000235 (vs $0.0007 for 120B)
    //    - Quality: All 10 days generated with proper progression
    if (tripDays >= 10 || routeKm >= 1500) {
      return process.env.GROQ_PLANNER_REASONER || 'openai/gpt-oss-20b'
    }

    // Default: versatile (good balance for medium trips)
    return 'llama-3.3-70b-versatile'
  }

  /**
   * Validate command input
   */
  private validateCommand(command: GenerateplanCommand): void {
    if (!command.from || !command.to) {
      throw new Error('Origin and destination are required')
    }

    if (command.from === command.to) {
      throw new Error('Origin and destination must be different')
    }

    if (!command.startDate || !command.endDate) {
      throw new Error('Start and end dates are required')
    }

    const startDate = new Date(command.startDate)
    const endDate = new Date(command.endDate)

    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
      throw new Error('Invalid date format')
    }

    if (endDate < startDate) {
      throw new Error('End date must be after start date')
    }

    // Check if dates are in the past
    const today = new Date()
    today.setHours(0, 0, 0, 0)
    if (startDate < today) {
      throw new Error('Start date cannot be in the past')
    }
  }

  /**
   * Fetch detailed data for all locations INCLUDING images and coordinates
   * This prevents redundant API calls by using existing database resources
   */
  private async fetchLocationsData(slugs: string[]) {
    const results = await Promise.all(
      slugs.map(async (slug) => {
        const result = await this.locationRepo.findBySlugWithDetails(slug)
        if (!result) {
          console.error(`‚ö†Ô∏è Could not find location data for slug: "${slug}"`)
        }
        return result
      })
    )

    const validResults = results.filter((result): result is NonNullable<typeof result> => result !== null)
    console.log(`‚úÖ Found ${validResults.length}/${slugs.length} locations with data`)

    // Fetch featured images for all locations from database
    const locationImages = await this.fetchLocationImages(validResults.map(r => r.location.slug))

    return validResults.map(result => ({
      name: result.location.name,
      slug: result.location.slug,
      latitude: result.location.latitude,
      longitude: result.location.longitude,
      country: result.location.country,
      region: result.location.region,
      featuredImage: locationImages[result.location.slug] || null,
      activities: result.activities,
      restaurants: result.restaurants,
      hasCompleteData: result.activities.length >= 5 && result.restaurants.length >= 3
    }))
  }

  /**
   * Fetch featured images from database for locations
   * Returns map of slug -> image URL
   */
  private async fetchLocationImages(slugs: string[]): Promise<Record<string, string>> {
    const { createClient } = await import('@supabase/supabase-js')
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
    )

    const { data, error } = await supabase
      .from('locations')
      .select('slug, featured_image, gallery_images')
      .in('slug', slugs)

    if (error) {
      console.error('‚ùå Error fetching location images:', error)
      return {}
    }

    const imageMap: Record<string, string> = {}
    data?.forEach((row: any) => {
      const url = row.featured_image || (Array.isArray(row.gallery_images) && row.gallery_images.length > 0 ? row.gallery_images[0] : null)
      if (url) {
        imageMap[row.slug] = url
      }
    })

    console.log(`üñºÔ∏è Found ${Object.keys(imageMap).length}/${slugs.length} featured images from locations table`)
    return imageMap
  }

  /**
   * Direct structured output from reasoning model
   * OPTIMIZED: Uses smart model selection + compressed prompts + reduced tokens
   * Single API call, no two-stage pipeline needed
   */
  private async generateWithDirectStructuredOutput(
    context: any,
    startDate: string
  ): Promise<any> {
    const groq = createGroqClient()

    // Build route stops for context
    const routeStops = [
      context.fromLocation,
      ...(context.structuredContext?.stops || []).map((s: any) => s.name || s),
      context.toLocation
    ].filter(Boolean)

    // OPTIMIZATION: Smart model selection
    // Use fast, cheap model for simple trips; reasoning model for complex trips
    const model = this.selectOptimalModel(context.totalDays, context.routeDistance)
    console.log(`ü§ñ Using model: ${model} (days: ${context.totalDays}, distance: ${context.routeDistance}km)`)

    const routeInfo = routeStops.length > 1
      ? `${routeStops.join(' ‚Üí ')} (${(context.routeDistance || 0).toFixed(0)}km)`
      : ''

    // OPTIMIZATION: Compressed system prompt (50% smaller)
    const systemPrompt = `Generate a ${context.totalDays}-day itinerary from ${routeInfo} in valid JSON.
- Exactly ${context.totalDays} days, sequential dates from ${startDate}
- Days progress through route: ${routeStops.join(' ‚Üí ')}
- Each day: {day, date, location, type, items[]}
- Return ONLY JSON, no markdown`

    const userPrompt = `Plan ${context.totalDays} days: ${context.fromLocation} ‚Üí ${context.toLocation}
Mode: ${context.transportMode || 'car'} | Budget: ${context.budget} | Interests: ${(context.interests || []).join(', ') || 'general'}

${context.structuredContext?.aiFormattedData ? `Data:\n${context.structuredContext.aiFormattedData}` : ''}

Return complete itinerary as JSON with all ${context.totalDays} days.`

    // OPTIMIZATION: Reduced max_tokens (37% reduction) + lower temperature (more deterministic)
    const response = await groq.chat.completions.create({
      model,
      temperature: 0.1, // OPTIMIZATION: Lower for more deterministic output
      max_tokens: 3500, // OPTIMIZATION: Tested with GPT-OSS 20B (generates full 10-day itineraries)
      response_format: { type: 'json_object' },
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt }
      ]
    })

    let content = response.choices?.[0]?.message?.content || '{}'
    console.log(`[Direct Structured] Response length: ${content.length}, First 300 chars:`, content.substring(0, 300))

    try {
      const parsed = JSON.parse(content)
      console.log(`‚úÖ Direct structured output parsed successfully: ${parsed.days?.length || 0} days`)
      return parsed
    } catch (error) {
      console.error(`‚ùå Failed to parse direct structured output:`, error)
      // Fallback: try to extract JSON from response
      const jsonMatch = content.match(/\{[\s\S]*\}/)
      if (jsonMatch) {
        try {
          const parsed = JSON.parse(jsonMatch[0])
          console.log(`‚úÖ Extracted JSON from response: ${parsed.days?.length || 0} days`)
          return parsed
        } catch {
          console.error(`‚ùå Failed to parse extracted JSON`)
        }
      }
      // Return empty structure to prevent crash
      return { days: [] }
    }
  }

  /**
   * PROFESSIONAL INTEGRATION: Enrich locations with AI-provided metadata
   * Updates database with continent, region data from AI
   */
  private async enrichLocationsWithAIMetadata(days: any[]) {
    const { LocationDiscoveryService } = await import('../../infrastructure/services/LocationDiscoveryService')
    const discoveryService = new LocationDiscoveryService()

    // Extract unique locations with their metadata from AI response
    const locationMetadataMap = new Map<string, any>()

    for (const day of days) {
      if (day.locationMetadata) {
        const locationName = day.location || day.locationMetadata.name
        if (!locationMetadataMap.has(locationName)) {
          locationMetadataMap.set(locationName, day.locationMetadata)
          console.log(`ü§ñ AI metadata for ${locationName}:`, day.locationMetadata)
        }
      }
    }

    // Enrich each location with AI metadata
    for (const [locationName, metadata] of Array.from(locationMetadataMap.entries())) {
      try {
        await discoveryService.findOrCreateLocationWithMetadata(locationName, metadata)
        console.log(`‚úÖ Enriched ${locationName} with AI metadata`)
      } catch (error) {
        console.error(`‚ö†Ô∏è Failed to enrich ${locationName}:`, error)
        // Don't fail the entire request if one location fails
      }
    }

    console.log(`‚úÖ Enriched ${locationMetadataMap.size} locations with AI metadata`)
  }
}

